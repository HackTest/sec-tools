#!/usr/bin/env python

# Copyright 2017, Ferry Boender.
# Licensed under the MIT license. For more information, see the LICENSE file.

import sys
import argparse
import logging
import json
import os
import imp
import inspect
import ast
import fnmatch

import tools

__VERSION__ = "0.1"


class Result:
    def __init__(self, desc, explanation, severity, passed=False):
        self.desc = desc
        self.explanation = explanation
        self.severity = severity
        self.has_passed = passed
        self.results = []
        self.plugin_name = None
        self.test_name = None

        assert(severity >= 0 and severity <= 5)

    def passed(self, passed=True):
        self.has_passed = passed

    def add_result(self, result):
        self.results.append(result)

    def set_plugin_name(self, plugin_name):
        self.plugin_name = plugin_name

    def set_test_name(self, test_name):
        self.test_name = test_name

    def to_dict(self):
        return {
            self.plugin_name: {
                self.test_name: {
                    "desc": self.desc,
                    "explanation": self.explanation,
                    "severity": self.severity,
                    "passed": self.has_passed,
                    "results": self.results,
                }
            }
        }


def load_plugins(debug=False):
    plugins = {}
    plugin_dir = 'sec-gather-misconfigs.d'
    logging.info("Loading plugins from {}".format(plugin_dir))
    for fname in os.listdir(plugin_dir):
        fname_parts = os.path.splitext(fname)
        plugin_name = fname_parts[0]
        if fname_parts[1] == ".py":
            # Load and execute Python code
            logging.info("Loading plugin {}".format(plugin_name))
            path = os.path.join(plugin_dir, fname)
            try:
                module = imp.load_source(plugin_name, path)
                module.Result = Result
            except Exception as err:
                logging.error("Couldn't import plugin '{}': {}".format(plugin_name, err))
                if debug is True:
                    logging.exception(err)
                continue

            for func_name, func_cb in inspect.getmembers(module, inspect.isfunction):
                if not func_name.startswith('_'):
                    logging.info("Found scan {}:{}".format(plugin_name, func_name))
                    plugins.setdefault(plugin_name, []).append(func_cb)
        else:
            logging.info("Skipping {}".format(fname))

    return plugins


def gather(config, skip_passed, limit, debug):
    plugins = load_plugins(debug=debug)
    results = {}
    for plugin_name in plugins.keys():
        for plugin_cb in plugins[plugin_name]:
            test_name = plugin_cb.__name__
            full_name = '{}:{}'.format(plugin_name, test_name)

            # Skip tests if not in limit. Can use wildcards such as 'net:*'
            if limit is not None:
                for match in limit:
                    if fnmatch.fnmatch(full_name, match):
                        # Test name found
                        break
                else:
                    # Test name not found
                    continue

            # Apply test configuration
            test_config = {}
            if plugin_name in config:
                if test_name in config[plugin_name]:
                    test_config = config[plugin_name][test_name]

            # Execute test
            logging.info("Executing test {}:{}".format(plugin_name, test_name))
            logging.debug("{}:{} config: {}".format(plugin_name, test_name, test_config))
            try:
                result = plugin_cb(**test_config)
                assert isinstance(result, Result)
                result.set_plugin_name(plugin_name)
                result.set_test_name(test_name)
                if result.has_passed is False or skip_passed is False:
                    tools.deepupdate(results, result.to_dict())
            except Exception as err:
                sys.stderr.write("Error executing test '{}:{}': {}: {}\n".format(plugin_name, test_name, type(err), err))
                if debug is True:
                    logging.exception(err)

                result = Result(desc="", explanation="", severity=0, passed=None)
                result.set_plugin_name(plugin_name)
                result.set_test_name(test_name)
                result.add_result("Error while executing the test: {}".format(tools.plain_err(err)))
                tools.deepupdate(results, result.to_dict())

    return results


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Gather unix users')
    parser.add_argument('--version', action='version', version=__VERSION__)
    parser.add_argument('-d, --debug', dest="debug", action='store_true', default=False, help="Show debug info")
    parser.add_argument('--skip-passed', dest="skip_passed", action="store_true", default=False, help="Don't include passed tests")
    parser.add_argument('--config', dest="config", action="store", type=str, default=None, help="Configuration file for tests")
    parser.add_argument('--limit', dest="limit", action="store", type=str, default=None, help="Limit which tests are executed")
    args = parser.parse_args()

    # Parse limit
    if args.limit is not None:
        args.limit = args.limit.split(',')

    # Setup logging
    loglevel = logging.ERROR
    if args.debug is True:
        loglevel = logging.DEBUG
    logging.basicConfig(level=loglevel)

    # Read configuration
    config = {}
    if args.config is not None:
        logging.info("Reading config {}".format(args.config))
        config = ast.literal_eval(open(args.config, 'r').read())

    # Run tests
    misconfigs = gather(config=config,
                        skip_passed=args.skip_passed,
                        limit=args.limit,
                        debug=args.debug)

    sys.stdout.write(json.dumps({"misconfigs": misconfigs}, indent=4))
